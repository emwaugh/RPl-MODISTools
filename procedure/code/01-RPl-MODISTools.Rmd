---
title: "RPl-MODISTools"
output: html_document
---
This study is a replication of the MODISTools vignette (located [here](https://cran.r-project.org/web/packages/MODISTools/vignettes/modistools-vignette.html)), which is an analysis of LAI (leaf area index) near the Bay of Arcachon, France.

The full MODISTools documentation can be found [here](https://cran.r-project.org/web/packages/MODISTools/MODISTools.pdf).

## Load packages
```{r load packages}
# list of required packages
packages = c("here", "MODISTools", "tidyverse", "raster", "dplyr", "stars")

# load and install required packages
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

# save the R processing environment to r_environment.txt
writeLines(capture.output(sessionInfo()),here("procedure","environment","r_environment.txt"))

```

## Finding data
There are many products (including bands and dates) availablefor access using MODISTools. To view all the available products from the MODIS sensor, with description, return interval, and resolution, run the following code:
```{r view available products from MODIS + description}
products <- mt_products()
head(products)
```
To view available bands for a given product:
```{r view available bands for a product}
bands <- mt_bands(product = "MCD15A3H")
head(bands)
```
To view available dates for a given product at a particular location:
```{r view available dates for a product}
dates <- mt_dates(product = "MCD15A3H", lat = 32, lon = -117)
head(dates)
```

## Download timeseries
Use `mt_subset()` to download timeseries. 
Output is saved to variables called "subset" and "LC" in the R workspace  (as defined by the parameter internal = TRUE, when set to FALSE the data is written to file).
**Emma, make it save to file**
This query may take a while.
```{r download MODIS land cover and LAI data}
# download the MODIS land cover (IGBP) and NDVI data
# for a region around the French city and basin of Arcachon

# leaf area index
fire_lai <- mt_subset(product = "MOD15A3H",
                      lat = 32.674,
                      lon =  -116.8054,
                      band = "Lai_500m",
                      start = "2003-04-01",
                      end = "2003-04-30",
                      km_lr = 20,
                      km_ab = 20,
                      site_name = "san diego",
                      internal = TRUE,
                      progress = FALSE)
# land cover
fire_lc <- mt_subset(product = "MCD12Q1",
                     lat = 32.674,
                     lon =  -116.8054,
                     band = "LC_Type1",
                     start = "2003-01-01",
                     end = "2003-12-31",
                     km_lr = 20,
                     km_ab = 20,
                     site_name = "san_diego",
                     internal = TRUE,
                     progress = FALSE)
```

## Process data
```{r merge land cover and leaf area index}
# merge land cover and lai data
fire <- fire_lc %>%
  rename("lc" = "value") %>%
  dplyr::select("lc","pixel") %>%
  right_join(fire_lai, by = "pixel")
```

```{r determine which classes are present}
fire %>%
  group_by(lc) %>% 
  summarise(count = sum(lc))
```
6 = closed shrublands
7 = open shrublands
9 = savannas
10 = grasslands
11 = permanent wetlands
12 = croplands
13 = urban and builtup lands
16 = barren
17 = water bodies

```{r check how many lc are NA}
fire %>% 
  filter(is.na(lc))
```


"Then, filter out all non valid values (> 100), only select evergreen and deciduous land cover classes (1 and 5, or, ENF and DBF respectively), convert them to more readable labels, and across these land cover classes take the **median per acquisition date**."

```{r filter non-valid values + rename classes + take median}
# create a plot of the data - accounting for the multiplier (scale) component
fire <- fire %>%
  filter(value <= 100,
         lc %in% c("6", "7", "9", "10", "11", "12", "13", "16")) %>% # retain everything but fill values
  mutate(lc = case_when(
    lc == 6 ~ "closedshrub",
    lc == 7 ~ "openshrub",
    lc == 9 ~ "savanna",
    lc == 10 ~ "grassland",
    lc == 11 ~ "wetland",
    lc == 12 ~ "cropland",
    lc == 13 ~ "urbanland",
    lc == 16 ~ "barren")) %>% 
  group_by(lc, calendar_date) %>% # group by lc and date
  summarize(doy = as.numeric(format(as.Date(calendar_date)[1],"%j")),
            lai_mean = median(value * as.double(scale)))
```

```{r check how many lc are NA}
fire %>% 
  filter(is.na(lc))
```
"Finally, the plot will show you the seasonal time series of LAI for both land cover classes (ENF and DBF). Note the difference in timing and amplitude between both these forest types, where the evergreen (ENF) pixels show lower LAI values and a more gradual seasonal pattern compared to the deciduous trees."

Use these plots to explain why to use April as peak vegetation time!
```{r plot LAI by date and per land cover class}
# plot LAI by date and per land cover class
ggplot(fire, aes(x = doy, y = lai_mean)) +
  geom_point() +
  geom_smooth(span = 0.3, method = "loess") +
  labs(x = "day of year (DOY)",
       y = "leaf area index (LAI)") +
  theme_minimal() +
  facet_wrap(~ lc, scales = "free")
```

```{r sinusoidal to lat-long}
# convert the coordinates from sinusoidal to lat-long
lat_lon <- sin_to_ll(fire_lc$xllcorner, fire_lc$yllcorner)

# bind with the original dataframe
subset <- cbind(fire_lc, lat_lon)

head(subset)

```

```{r calculate bounding box of extracted data}
# convert to bounding box
bb <- apply(fire_lc, 1, function(x){
  mt_bbox(xllcorner = x['xllcorner'],
          yllcorner = x['yllcorner'],
           cellsize = x['cellsize'],
           nrows = x['nrows'],
           ncols = x['ncols'])
})

# plot one bounding box
plot(bb[[1]])

# add the location of the queried coordinate within the polygon
points(fire_lc$longitude[1],
       fire_lc$latitude[1],
       pch = 20,
       col = "red")
```

## Convert to gridded raster data
```{r convert to raster & plot}
# convert to raster, when reproject is TRUE
# the data is reprojected to lat / lon if FALSE
# the data is shown in its original sinuidal projection
LC_r <- mt_to_raster(df = fire_lc, reproject = TRUE)

# plot the raster data as a map
plot(LC_r)
```

```{r write raster to .tif file}
LC_r_stars <- st_as_stars(LC_r)

write_stars(LC_r_stars, here("results","other","LC_r.tif"))
```


## This stuff might not be important
```{r convert from sinusoidal to lat-long part 2}
# convert the coordinates from sinusoidal to lat-long
lat_lon_lai <- sin_to_ll(fire_lai$xllcorner, fire_lai$yllcorner)

# bind with the original dataframe
subset_lai <- cbind(fire_lai, lat_lon_lai)

head(subset_lai)
```

```{r calculate bounding box of extracted data}
# convert to bounding box
bb_lai <- apply(fire_lai, 1, function(x){
  mt_bbox(xllcorner = x['xllcorner'],
          yllcorner = x['yllcorner'],
           cellsize = x['cellsize'],
           nrows = x['nrows'],
           ncols = x['ncols'])
})

# plot one bounding box
plot(bb_lai[[1]])

# add the location of the queried coordinate within the polygon
points(fire_lai$longitude[1],
       fire_lai$latitude[1],
       pch = 20,
       col = "red")
```

```{r convert to raster part ?}
# convert to raster, when reproject is TRUE
# the data is reprojected to lat / lon if FALSE
# the data is shown in its original sinuidal projection
LAI_r <- mt_to_raster(df = fire_lai, reproject = TRUE)

# plot the raster data as a map
plot(LAI_r)
```

```{r convert to raster part ?}
# convert to raster, when reproject is TRUE
# the data is reprojected to lat / lon if FALSE
# the data is shown in its original sinuidal projection
LAI_r_ll <- mt_to_raster(df = fire_lai, reproject = TRUE)

# plot the raster data as a map
plot(LAI_r_ll)
```